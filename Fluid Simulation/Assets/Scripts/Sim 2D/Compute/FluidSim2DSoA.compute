#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForce
#pragma kernel CalculateViscosity
#pragma kernel UpdatePositions

// Includes
#include "./FluidMaths2DAoS.hlsl"
#include "./SpatialHash.hlsl"

static const int NumThreads = 64;

// Condensed version of FluidData ScriptableObject (without shader details as those are not needed)
struct FluidData
{
	// Fluid properties
	int fluidType; // fluid type enum
	float1 gravity;
	float1 collisionDamping;
	float1 smoothingRadius;
	float1 targetDensity;
	float1 pressureMultiplier;
	float1 nearPressureMultiplier;
	float1 viscosityStrength;
};

struct Circle //12 bytes total
{
    float2 pos; //8 bytes
    float radius; //4 bytes
};

struct OrientedBox //24 bytes total
{
    float2 pos; //8 bytes
    float2 size;
    float2 zLocal;
};

struct ScalingFactors
{
	float Poly6;
	float SpikyPow3;
	float SpikyPow2;
	float SpikyPow3Derivative;
	float SpikyPow2Derivative;
};

// Buffers
RWStructuredBuffer<FluidData> FluidDataSet;
RWStructuredBuffer<ScalingFactors> ScalingFactorsBuffer;
RWStructuredBuffer<float2> Densities;
RWStructuredBuffer<float2> Velocities;
RWStructuredBuffer<float2> PredictedPositions;
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float1> Temperatures;
RWStructuredBuffer<int> FluidTypes;
RWStructuredBuffer<uint3> SpatialIndices; // used for spatial hashing index, hash, key
RWStructuredBuffer<uint> SpatialOffsets; // used for spatial hashing
RWStructuredBuffer<OrientedBox> BoxColliders;
RWStructuredBuffer<Circle> CircleColliders;

// Settings
const uint numParticles;
const float deltaTime;
const float2 boundsSize;
const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;
const float maxSmoothingRadius;

int numBoxColliders;
int numCircleColliders;
int brushType;
int selectedFluidType;

float DensityKernel(float dst, float radius, int type)
{
	return SpikyKernelPow2(dst, radius, ScalingFactorsBuffer[type - 1].SpikyPow2);
}

float NearDensityKernel(float dst, float radius, int type)
{
	return SpikyKernelPow3(dst, radius, ScalingFactorsBuffer[type - 1].SpikyPow3);
}

float DensityDerivative(float dst, float radius, int type)
{
	return DerivativeSpikyPow2(dst, radius, ScalingFactorsBuffer[type - 1].SpikyPow2Derivative);
}

float NearDensityDerivative(float dst, float radius, int type)
{
	return DerivativeSpikyPow3(dst, radius, ScalingFactorsBuffer[type - 1].SpikyPow3Derivative);
}

float ViscosityKernel(float dst, float radius, int type)
{
	return SmoothingKernelPoly6(dst, radius, ScalingFactorsBuffer[type - 1].Poly6);
}

//get the maximum smoothing radius between two fluid types
float GetMaxSmoothingRadius(int typeA, int typeB)
{
    return max(FluidDataSet[typeA - 1].smoothingRadius, FluidDataSet[typeB - 1].smoothingRadius);
}

float2 CalculateDensity(float2 pos, float smoothingRadius, int type)
{
	int2 originCell = GetCell2D(pos, maxSmoothingRadius); //Use the largest radius of any fluid type for spatial hashing
	float sqrRadius = smoothingRadius * smoothingRadius;
	float density = 0;
	float nearDensity = 0;

	// Add self-density contribution
	//density += DensityKernel(0, smoothingRadius, type);
	//nearDensity += NearDensityKernel(0, smoothingRadius, type);

	// Neighbour search
	for (int i = 0; i < 9; i++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			FluidData neighbourData = FluidDataSet[FluidTypes[neighbourIndex] - 1];

			if (FluidTypes[neighbourIndex] == 0) continue; // Skip disabled particles

			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Use max smoothing radius between the two particle types
            float interactionRadius = GetMaxSmoothingRadius(type, FluidTypes[neighbourIndex]);
            float sqrRadius = interactionRadius * interactionRadius;

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			density += DensityKernel(dst, smoothingRadius, type); // NEW Kernel that uses type
			nearDensity += NearDensityKernel(dst, smoothingRadius, type);
		}
	}

	return float2(density, nearDensity);
}

float PressureFromDensity(float density, float targetDensity, float pressureMultiplier)
{
	return (density - targetDensity) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity, float nearPressureMultiplier)
{
	return nearPressureMultiplier * nearDensity;
}

float2 ExternalForces(float2 pos, float2 velocity, float gravity)
{
	// Gravity
	float2 gravityAccel = float2(0, gravity);
	
	// Input interactions modify gravity
	if (interactionInputStrength != 0) {
		float2 inputPointOffset = interactionInputPoint - pos;
		float sqrDst = dot(inputPointOffset, inputPointOffset);
		if (sqrDst < interactionInputRadius * interactionInputRadius)
		{
			float dst = sqrt(sqrDst);
			float edgeT = (dst / interactionInputRadius);
			float centreT = 1 - edgeT;
			float2 dirToCentre = inputPointOffset / dst;

			float gravityWeight = 1 - (centreT * saturate(interactionInputStrength / 10));
			float2 accel = gravityAccel * gravityWeight + dirToCentre * centreT * interactionInputStrength;
			accel -= velocity * centreT;
			return accel;
		}
	}

	return gravityAccel;
}

void HandleBoxCollision(inout float2 pos, inout float2 vel, OrientedBox box, float collisionDamping)
{
    // Transform position to box's local space
    float2 localPos = pos - box.pos;

    // Create rotation matrix for local space transformation
    float2 right = box.zLocal;
    float2 up = float2(-box.zLocal.y, box.zLocal.x);

    // Transform to box's local space
    float2 rotatedPos = float2(
        dot(localPos, right),
        dot(localPos, up)
    );

    // Calculate distance to box edges in local space
    float2 boxHalfSize = box.size * 0.5;
    float2 distanceFromCenter = abs(rotatedPos);
    float2 penetration = distanceFromCenter - boxHalfSize;

    // Only process collision if we're actually inside the box
    if (penetration.x < 0 && penetration.y < 0)
    {
        // Transform velocity to local space
        float2 localVel = float2(
            dot(vel, right),
            dot(vel, up)
        );

        // Determine which axis has less penetration
        if (penetration.x > penetration.y)
        {
            // X axis collision
            float sign = rotatedPos.x > 0 ? 1 : -1;
            rotatedPos.x = boxHalfSize.x * sign;
            localVel.x *= -1 * collisionDamping;
        }
        else
        {
            // Y axis collision
            float sign = rotatedPos.y > 0 ? 1 : -1;
            rotatedPos.y = boxHalfSize.y * sign;
            localVel.y *= -1 * collisionDamping;
        }

        // Transform position back to world space
        pos = box.pos + right * rotatedPos.x + up * rotatedPos.y;

        // Transform velocity back to world space
        vel = right * localVel.x + up * localVel.y;
    }
}

void HandleBoxCollision2(inout float2 pos, inout float2 vel, OrientedBox box, float collisionDamping)
{
    // Transform position to box's local space (combined operations)
    float2 right = box.zLocal;
    float2 up = float2(-box.zLocal.y, box.zLocal.x); // Precompute once
    
    // Combined transformation to local space (reduced operations)
    float2 localPos = pos - box.pos;
    float2 rotatedPos = float2(
        dot(localPos, right),
        dot(localPos, up)
    );

    // Early exit optimization
    float2 boxHalfSize = box.size * 0.5;
    float2 distanceFromCenter = abs(rotatedPos);
    float2 penetration = distanceFromCenter - boxHalfSize;
    
    // Skip all calculations if no collision (combined comparison)
    if (penetration.x >= 0 || penetration.y >= 0)
        return;

    // Transform velocity to local space (only if collision detected)
    float2 localVel = float2(
        dot(vel, right),
        dot(vel, up)
    );

    // Branchless version of axis selection
    bool useXAxis = penetration.x > penetration.y;
    float penetrationAmount = useXAxis ? penetration.x : penetration.y;
    float sign = useXAxis ? (rotatedPos.x > 0 ? 1 : -1) : (rotatedPos.y > 0 ? 1 : -1);
    
    // Branchless position and velocity update
    rotatedPos = useXAxis ? 
        float2(boxHalfSize.x * sign, rotatedPos.y) : 
        float2(rotatedPos.x, boxHalfSize.y * sign);
    
    localVel = useXAxis ? 
        float2(-localVel.x * collisionDamping, localVel.y) : 
        float2(localVel.x, -localVel.y * collisionDamping);

    // Transform back to world space (single operation)
    pos = box.pos + right * rotatedPos.x + up * rotatedPos.y;
    vel = right * localVel.x + up * localVel.y;
}

void HandleCollisions(inout int pIdx)
{
    float2 pos = Positions[pIdx];
    float2 vel = Velocities[pIdx];
	FluidData fluidData = FluidDataSet[FluidTypes[pIdx] - 1];

    // Keep particle inside bounds
    const float2 halfSize = boundsSize * 0.5;
    float2 edgeDst = halfSize - abs(pos);

    if (edgeDst.x <= 0)
    {
        pos.x = halfSize.x * sign(pos.x);
        vel.x *= -1 * fluidData.collisionDamping;
    }
    if (edgeDst.y <= 0)
    {
        pos.y = halfSize.y * sign(pos.y);
        vel.y *= -1 * fluidData.collisionDamping;
    }

    // Handle box collisions
    for (int i = 0; i < numBoxColliders; i++)
    {
        HandleBoxCollision(pos, vel, BoxColliders[i], fluidData.collisionDamping);
    }

    // Update position and velocity in the particle struct
    Positions[pIdx] = pos;
    Velocities[pIdx] = vel;
}
void HandleLeftMouseInput(inout int pIdx){
	// Input interactions to add particles
	if (brushType == 0 && interactionInputStrength == 1) {
		float2 inputPointOffset = interactionInputPoint - Positions[pIdx];
		float sqrDst = dot(inputPointOffset, inputPointOffset);

		if(FluidTypes[pIdx] == 0){
			Positions[pIdx] = interactionInputPoint - inputPointOffset * (interactionInputRadius / sqrt(sqrDst));
			FluidTypes[pIdx] = selectedFluidType; // Reactivate the particle by setting it to non 0
		}

	}
}
void HandleRightMouseInput(inout int pIdx){
	// Input interactions to remove particles
	if (brushType == 0 && interactionInputStrength == -1) {
		float2 inputPointOffset = interactionInputPoint - Positions[pIdx];
		float sqrDst = dot(inputPointOffset, inputPointOffset);
		if (sqrDst < interactionInputRadius * interactionInputRadius)
		{
			FluidTypes[pIdx] = 0; // Remove the particle by setting to 0 which is disabled.
		}
	}
}

[numthreads(NumThreads,1,1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;
	HandleLeftMouseInput(id.x);
	if (FluidTypes[id.x] == 0) return; // Skip disabled

	FluidData fluidData = FluidDataSet[FluidTypes[id.x] - 1];
	
    // External forces (gravity and input interaction)
    Velocities[id.x] += ExternalForces(Positions[id.x], Velocities[id.x], fluidData.gravity) * deltaTime;

	HandleRightMouseInput(id.x);

    // Predict
    const float predictionFactor = 1 / 120.0;
    PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * predictionFactor;
}

[numthreads(NumThreads,1,1)]
void UpdateSpatialHash (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Reset offsets
	SpatialOffsets[id.x] = numParticles;
	// Update index buffer
	uint index = id.x;
	int2 cell = GetCell2D(PredictedPositions[id.x], maxSmoothingRadius);
	uint hash = HashCell2D(cell);
	uint key = KeyFromHash(hash, numParticles);
	SpatialIndices[id.x] = uint3(index, hash, key);
}

[numthreads(NumThreads,1,1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;
	if (FluidTypes[id.x] == 0) return; // Skip disabled

	FluidData fluidData = FluidDataSet[FluidTypes[id.x] - 1];
    Densities[id.x] = CalculateDensity(PredictedPositions[id.x], fluidData.smoothingRadius, FluidTypes[id.x]); // This needs the fluidData
	//particle.density.x = max(particle.density.x, 0.1); // Clamp density
    //particle.density.y = max(particle.density.y, 0.1);
}

[numthreads(NumThreads,1,1)]
void CalculatePressureForce (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	if (FluidTypes[id.x] == 0) return; // Skip disabled

	FluidData fluidData = FluidDataSet[FluidTypes[id.x] - 1];

	float density = Densities[id.x][0];
	float densityNear = Densities[id.x][1];
	float pressure = PressureFromDensity(density, fluidData.targetDensity, fluidData.pressureMultiplier);
	float nearPressure = NearPressureFromDensity(densityNear, fluidData.nearPressureMultiplier);
	float2 pressureForce = 0;
	
	float2 pos = PredictedPositions[id.x];
	int2 originCell = GetCell2D(pos, maxSmoothingRadius);
	float sqrRadius = fluidData.smoothingRadius * fluidData.smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 9; i ++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin (index, hash, key)
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			// Skip if looking at self
			if (neighbourIndex == id.x) continue;
			if (FluidTypes[neighbourIndex] == 0) continue; // Skip disabled
			
			FluidData neighbourData = FluidDataSet[FluidTypes[neighbourIndex] - 1];

			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate pressure force
			float dst = sqrt(sqrDstToNeighbour);
			float2 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : float2(0, 1);

			float neighbourDensity = Densities[neighbourIndex][0];
			float neighbourNearDensity = Densities[neighbourIndex][1];
			float neighbourPressure = PressureFromDensity(neighbourDensity, neighbourData.targetDensity, neighbourData.pressureMultiplier);
			float neighbourNearPressure = NearPressureFromDensity(neighbourNearDensity, neighbourData.nearPressureMultiplier);

			float sharedPressure = (pressure + neighbourPressure) * 0.5;
			float sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;

			pressureForce += dirToNeighbour * DensityDerivative(dst, fluidData.smoothingRadius, FluidTypes[id.x]) * sharedPressure / neighbourDensity;
			pressureForce += dirToNeighbour * NearDensityDerivative(dst, fluidData.smoothingRadius, FluidTypes[id.x]) * sharedNearPressure / neighbourDensity;
		}
	}

	float2 acceleration = pressureForce / density;
	Velocities[id.x] += acceleration * deltaTime;//
}



[numthreads(NumThreads,1,1)]
void CalculateViscosity (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	if (FluidTypes[id.x] == 0) return; // Skip disabled

	FluidData fluidData = FluidDataSet[FluidTypes[id.x] - 1];
		
	float2 pos = PredictedPositions[id.x];
	int2 originCell = GetCell2D(pos, maxSmoothingRadius);
	float sqrRadius = fluidData.smoothingRadius * fluidData.smoothingRadius;

	float2 viscosityForce = 0;
	float2 velocity = Velocities[id.x];

	for (int i = 0; i < 9; i ++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			// Skip if looking at self
			if (neighbourIndex == id.x) continue;
			if (FluidTypes[neighbourIndex] == 0) continue; // Skip disabled

			FluidData neighbourData = FluidDataSet[FluidTypes[neighbourIndex] - 1];

			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			float dst = sqrt(sqrDstToNeighbour);
			float2 neighbourVelocity = Velocities[neighbourIndex];
			viscosityForce += (neighbourVelocity - velocity) * ViscosityKernel(dst, fluidData.smoothingRadius, FluidTypes[id.x]);
		}

	}
	Velocities[id.x] += viscosityForce * fluidData.viscosityStrength * deltaTime;
}

[numthreads(NumThreads,1,1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;
    //Particle particle = Particles[id.x];
	if (FluidTypes[id.x] == 0) return; // Skip disabled
    Positions[id.x] += Velocities[id.x] * deltaTime;
    HandleCollisions(id.x); // This needs the FluidDataSet
}